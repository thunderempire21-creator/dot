<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dots and Boxes with Suggester</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            touch-action: none; /* Prevents scrolling on mobile */
        }
        canvas {
            cursor: pointer;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .player-card {
            transition: all 0.3s ease-in-out;
            border-width: 4px;
        }
        .player-red.active {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.7);
            border-color: #ef4444;
        }
        .player-blue.active {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.7);
            border-color: #3b82f6;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .selected-btn {
            border-color: #facc15; /* Yellow border for selected buttons */
            box-shadow: 0 0 10px #facc15;
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-2xl mx-auto">
        <h1 class="text-3xl md:text-4xl font-bold text-center mb-4">Dots and Boxes</h1>
        
        <!-- Game Setup Screen -->
        <div id="game-setup" class="text-center mb-6 bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md">
            <div id="ai-selection" class="mb-4">
                <p class="font-semibold mb-2 text-lg">1. Choose which player the AI should assist:</p>
                <div class="flex justify-center gap-4">
                    <button id="assistRedBtn" class="border-4 border-transparent bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition-all">Assist Red</button>
                    <button id="assistBlueBtn" class="border-4 border-transparent bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition-all">Assist Blue</button>
                </div>
            </div>
            <div id="start-selection" class="mb-4">
                <p class="font-semibold mb-2 text-lg">2. Choose which player starts the game:</p>
                <div class="flex justify-center gap-4">
                    <button id="startRedBtn" class="border-4 border-transparent bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition-all">Red Starts</button>
                    <button id="startBlueBtn" class="border-4 border-transparent bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition-all">Blue Starts</button>
                </div>
            </div>
            <button id="startGameBtn" class="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-6 rounded-lg mt-4 text-xl" disabled>Start Game</button>
        </div>
        
        <!-- Player Info and Scores (hidden initially) -->
        <div id="game-interface" class="hidden">
            <div class="grid grid-cols-2 gap-4 mb-4">
                <div id="player-red-card" class="player-card player-red bg-white dark:bg-gray-800 p-4 rounded-lg border-transparent">
                    <h2 class="text-xl font-bold text-red-500">Player Red</h2>
                    <p class="text-3xl font-bold" id="score-red">0</p>
                </div>
                <div id="player-blue-card" class="player-card player-blue bg-white dark:bg-gray-800 p-4 rounded-lg text-right border-transparent">
                    <h2 class="text-xl font-bold text-blue-500">Player Blue</h2>
                    <p class="text-3xl font-bold" id="score-blue">0</p>
                </div>
            </div>

            <!-- Game Canvas -->
            <div class="relative">
                <canvas id="gameCanvas" class="bg-white dark:bg-gray-800 w-full"></canvas>
                <div id="messageBox" class="absolute inset-0 bg-black bg-opacity-60 flex-col items-center justify-center rounded-lg text-white text-center p-4 hidden">
                    <p id="messageText" class="text-3xl font-bold mb-4"></p>
                    <button id="newGameBtn" class="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-6 rounded-lg text-lg">Play Again</button>
                </div>
            </div>
            
            <div class="mt-4 flex justify-between items-center">
                <button id="skipBtn" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg">
                    Skip Turn
                </button>
                <button id="restartBtn" class="bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-200 font-bold py-2 px-4 rounded-lg">
                    Restart Game
                </button>
                <button id="undoBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg">
                    Undo Move
                </button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- Game Configuration ---
        const DOTS = 6;
        const BOXES = DOTS - 1;
        const RED = '#ef4444';
        const BLUE = '#3b82f6';
        const RED_LIGHT = 'rgba(239, 68, 68, 0.4)';
        const BLUE_LIGHT = 'rgba(59, 130, 246, 0.4)';
        const SUGGESTION_COLOR = '#facc15';
        const DOT_COLOR = '#9ca3af';
        const DARK_DOT_COLOR = '#4b5563';

        // --- Game State ---
        let hLines, vLines, boxes;
        let currentPlayer;
        let scores;
        let gameOver;
        let gameStarted;
        let aiAssistedPlayer = null;
        let startingPlayer = null;
        let dotRadius, spacing;
        let history = [];

        // --- UI Elements ---
        const scoreRedEl = document.getElementById('score-red');
        const scoreBlueEl = document.getElementById('score-blue');
        const playerRedCard = document.getElementById('player-red-card');
        const playerBlueCard = document.getElementById('player-blue-card');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const newGameBtn = document.getElementById('newGameBtn');
        const restartBtn = document.getElementById('restartBtn');
        const skipBtn = document.getElementById('skipBtn');
        const undoBtn = document.getElementById('undoBtn');
        const gameSetupDiv = document.getElementById('game-setup');
        const gameInterfaceDiv = document.getElementById('game-interface');
        const assistRedBtn = document.getElementById('assistRedBtn');
        const assistBlueBtn = document.getElementById('assistBlueBtn');
        const startRedBtn = document.getElementById('startRedBtn');
        const startBlueBtn = document.getElementById('startBlueBtn');
        const startGameBtn = document.getElementById('startGameBtn');

        // --- Utility Functions ---
        const isDarkMode = () => window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;

        /**
         * Initializes or resets the game to its pre-start state.
         */
        function init() {
            scores = { red: 0, blue: 0 };
            gameOver = false;
            gameStarted = false;
            currentPlayer = null;
            aiAssistedPlayer = null;
            startingPlayer = null;
            history = [];

            gameSetupDiv.classList.remove('hidden');
            gameInterfaceDiv.classList.add('hidden');
            messageBox.classList.add('hidden');
            messageBox.classList.remove('flex');
            
            startGameBtn.disabled = true;
            assistRedBtn.classList.remove('selected-btn');
            assistBlueBtn.classList.remove('selected-btn');
            startRedBtn.classList.remove('selected-btn');
            startBlueBtn.classList.remove('selected-btn');
            
            hLines = Array(BOXES).fill(0).map(() => Array(DOTS).fill(0));
            vLines = Array(DOTS).fill(0).map(() => Array(BOXES).fill(0));
            boxes = Array(BOXES).fill(0).map(() => Array(BOXES).fill(0));
            
            resizeCanvas(); 
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function selectAiPlayer(player) {
            aiAssistedPlayer = player;
            assistRedBtn.classList.toggle('selected-btn', player === 'red');
            assistBlueBtn.classList.toggle('selected-btn', player === 'blue');
            checkSelections();
        }

        function selectStartingPlayer(player) {
            startingPlayer = player;
            startRedBtn.classList.toggle('selected-btn', player === 'red');
            startBlueBtn.classList.toggle('selected-btn', player === 'blue');
            checkSelections();
        }

        function checkSelections() {
            if (aiAssistedPlayer && startingPlayer) {
                startGameBtn.disabled = false;
            }
        }

        function startGame() {
            if (!aiAssistedPlayer || !startingPlayer) return;
            gameStarted = true;
            currentPlayer = startingPlayer;
            gameSetupDiv.classList.add('hidden');
            gameInterfaceDiv.classList.remove('hidden');
            resizeCanvas();
            updateUI();
            draw();
        }

        function skipTurn() {
            if (gameOver || !gameStarted) return;
            currentPlayer = currentPlayer === 'red' ? 'blue' : 'red';
            updateUI();
            draw();
        }

        function undoMove() {
            if (history.length === 0 || !gameStarted || gameOver) return;
            const lastState = history.pop();
            hLines = lastState.hLines;
            vLines = lastState.vLines;
            boxes = lastState.boxes;
            scores = lastState.scores;
            currentPlayer = lastState.currentPlayer;
            gameOver = false;
            messageBox.classList.add('hidden');
            messageBox.classList.remove('flex');
            updateUI();
            draw();
        }

        function resizeCanvas() {
            const containerWidth = gameInterfaceDiv.clientWidth || document.querySelector('.max-w-2xl').clientWidth;
            const canvasContainer = canvas.parentElement;
            canvas.width = canvasContainer.clientWidth;
            canvas.height = canvasContainer.clientWidth;
            spacing = canvas.width / (DOTS + 1);
            dotRadius = spacing / 8;
            if(gameStarted) draw();
        }

        function updateUI() {
            scoreRedEl.textContent = scores.red;
            scoreBlueEl.textContent = scores.blue;
            skipBtn.disabled = !gameStarted || gameOver;
            undoBtn.disabled = history.length === 0 || !gameStarted || gameOver;
            if (gameOver) {
                playerRedCard.classList.remove('active');
                playerBlueCard.classList.remove('active');
            } else {
                playerRedCard.classList.toggle('active', currentPlayer === 'red');
                playerBlueCard.classList.toggle('active', currentPlayer === 'blue');
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBoxes();
            drawLines();
            if (!gameOver && gameStarted) {
                drawSuggestion();
            }
            drawDots();
        }

        function drawDots() {
            ctx.fillStyle = isDarkMode() ? DARK_DOT_COLOR : DOT_COLOR;
            for (let i = 0; i < DOTS; i++) {
                for (let j = 0; j < DOTS; j++) {
                    ctx.beginPath();
                    ctx.arc(spacing * (j + 1), spacing * (i + 1), dotRadius, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
        }

        function drawLines() {
            ctx.lineWidth = dotRadius / 1.5;
            ctx.lineCap = 'round';
            for (let i = 0; i < BOXES; i++) {
                for (let j = 0; j < DOTS; j++) {
                    if (hLines[i][j]) {
                        ctx.strokeStyle = hLines[i][j] === 'red' ? RED : BLUE;
                        ctx.beginPath();
                        ctx.moveTo(spacing * (i + 1), spacing * (j + 1));
                        ctx.lineTo(spacing * (i + 2), spacing * (j + 1));
                        ctx.stroke();
                    }
                }
            }
            for (let i = 0; i < DOTS; i++) {
                for (let j = 0; j < BOXES; j++) {
                    if (vLines[i][j]) {
                        ctx.strokeStyle = vLines[i][j] === 'red' ? RED : BLUE;
                        ctx.beginPath();
                        ctx.moveTo(spacing * (i + 1), spacing * (j + 1));
                        ctx.lineTo(spacing * (i + 1), spacing * (j + 2));
                        ctx.stroke();
                    }
                }
            }
        }

        function drawBoxes() {
            for (let i = 0; i < BOXES; i++) {
                for (let j = 0; j < BOXES; j++) {
                    if (boxes[i][j]) {
                        ctx.fillStyle = boxes[i][j] === 'red' ? RED_LIGHT : BLUE_LIGHT;
                        ctx.fillRect(spacing * (i + 1) + dotRadius, spacing * (j + 1) + dotRadius, spacing - dotRadius * 2, spacing - dotRadius * 2);
                    }
                }
            }
        }
        
        function drawSuggestion() {
            if (currentPlayer !== aiAssistedPlayer) return;
            const move = getBestMove();
            if (!move) return;
            ctx.strokeStyle = SUGGESTION_COLOR;
            ctx.lineWidth = dotRadius;
            ctx.lineCap = 'round';
            ctx.beginPath();
            if (move.type === 'h') {
                ctx.moveTo(spacing * (move.x + 1), spacing * (move.y + 1));
                ctx.lineTo(spacing * (move.x + 2), spacing * (move.y + 1));
            } else {
                ctx.moveTo(spacing * (move.x + 1), spacing * (move.y + 1));
                ctx.lineTo(spacing * (move.x + 1), spacing * (move.y + 2));
            }
            ctx.stroke();
        }

        function handleInteraction(e) {
            if (gameOver || !gameStarted) return;
            e.preventDefault();
            let clientX, clientY;
            if (e.touches) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            const rect = canvas.getBoundingClientRect();
            const x = clientX - rect.left;
            const y = clientY - rect.top;
            const clickThreshold = spacing * 0.4;
            for (let i = 0; i < BOXES; i++) {
                for (let j = 0; j < DOTS; j++) {
                    const lineCenterX = spacing * (i + 1.5);
                    const lineCenterY = spacing * (j + 1);
                    if (Math.abs(x - lineCenterX) < spacing / 2 && Math.abs(y - lineCenterY) < clickThreshold) {
                        if (!hLines[i][j]) {
                            playMove('h', i, j);
                            return;
                        }
                    }
                }
            }
            for (let i = 0; i < DOTS; i++) {
                for (let j = 0; j < BOXES; j++) {
                    const lineCenterX = spacing * (i + 1);
                    const lineCenterY = spacing * (j + 1.5);
                    if (Math.abs(x - lineCenterX) < clickThreshold && Math.abs(y - lineCenterY) < spacing / 2) {
                        if (!vLines[i][j]) {
                            playMove('v', i, j);
                            return;
                        }
                    }
                }
            }
        }
        
        function playMove(type, x, y) {
            history.push({
                hLines: JSON.parse(JSON.stringify(hLines)),
                vLines: JSON.parse(JSON.stringify(vLines)),
                boxes: JSON.parse(JSON.stringify(boxes)),
                scores: { ...scores },
                currentPlayer: currentPlayer
            });
            let scored = false;
            if (type === 'h' && !hLines[x][y]) {
                hLines[x][y] = currentPlayer;
                scored = checkBoxCompletion(x, y, 'h');
            } else if (type === 'v' && !vLines[x][y]) {
                vLines[x][y] = currentPlayer;
                scored = checkBoxCompletion(x, y, 'v');
            } else {
                history.pop();
                return;
            }
            if (!scored) {
                currentPlayer = currentPlayer === 'red' ? 'blue' : 'red';
            }
            updateUI();
            draw();
            checkGameOver();
        }

        function checkBoxCompletion(x, y, type) {
            let boxCompleted = false;
            if (type === 'h') {
                if (y < BOXES && vLines[x][y] && vLines[x + 1][y] && hLines[x][y + 1]) {
                    if (!boxes[x][y]) { boxes[x][y] = currentPlayer; scores[currentPlayer]++; boxCompleted = true; }
                }
                if (y > 0 && vLines[x][y - 1] && vLines[x + 1][y - 1] && hLines[x][y - 1]) {
                    if (!boxes[x][y-1]) { boxes[x][y - 1] = currentPlayer; scores[currentPlayer]++; boxCompleted = true; }
                }
            } else { 
                if (x < BOXES && hLines[x][y] && hLines[x][y + 1] && vLines[x + 1][y]) {
                    if (!boxes[x][y]) { boxes[x][y] = currentPlayer; scores[currentPlayer]++; boxCompleted = true; }
                }
                if (x > 0 && hLines[x - 1][y] && hLines[x - 1][y + 1] && vLines[x - 1][y]) {
                    if (!boxes[x-1][y]) { boxes[x - 1][y] = currentPlayer; scores[currentPlayer]++; boxCompleted = true; }
                }
            }
            return boxCompleted;
        }

        function checkGameOver() {
            if (scores.red + scores.blue === BOXES * BOXES) {
                gameOver = true;
                let winnerText;
                if (scores.red > scores.blue) winnerText = "Red Wins!";
                else if (scores.blue > scores.red) winnerText = "Blue Wins!";
                else winnerText = "It's a Draw!";
                messageText.textContent = winnerText;
                messageBox.classList.remove('hidden');
                messageBox.classList.add('flex');
                updateUI();
            }
        }
        
        // --- GRANDMASTER AI LOGIC ---

        function countSides(x, y) {
            let count = 0;
            if (hLines[x][y]) count++; if (hLines[x][y + 1]) count++;
            if (vLines[x][y]) count++; if (vLines[x + 1][y]) count++;
            return count;
        }

        function countSidesOnTemp(x, y, tempHLines, tempVLines) {
            let count = 0;
            if (tempHLines[x][y]) count++; if (tempHLines[x][y + 1]) count++;
            if (tempVLines[x][y]) count++; if (tempVLines[x + 1][y]) count++;
            return count;
        }

        function analyzeChains(h, v) {
            const chains = [];
            const visited = Array(BOXES).fill(0).map(() => Array(BOXES).fill(false));
            for (let i = 0; i < BOXES; i++) {
                for (let j = 0; j < BOXES; j++) {
                    if (!visited[i][j] && countSidesOnTemp(i, j, h, v) === 2) {
                        let currentChainLength = 0;
                        const queue = [[i, j]];
                        visited[i][j] = true;
                        while (queue.length > 0) {
                            const [cx, cy] = queue.shift();
                            currentChainLength++;
                            const neighbors = [[cx, cy - 1], [cx, cy + 1], [cx - 1, cy], [cx + 1, cy]];
                            for (const [nx, ny] of neighbors) {
                                if (nx >= 0 && nx < BOXES && ny >= 0 && ny < BOXES && !visited[nx][ny]) {
                                    if (countSidesOnTemp(nx, ny, h, v) === 2) {
                                        // Check if the boxes are connected by an empty line
                                        if ((nx === cx && !v[Math.min(nx,cx)][Math.min(ny, cy)]) || (ny === cy && !h[Math.min(nx, cx)][Math.min(ny,cy)+1])) {
                                            visited[nx][ny] = true;
                                            queue.push([nx, ny]);
                                        }
                                    }
                                }
                            }
                        }
                        chains.push(currentChainLength);
                    }
                }
            }
            return chains;
        }

        /**
         * [UPDATED] Simulates the outcome of a sacrificial move, assuming optimal play from both sides.
         * This function calculates the net score difference from the AI's perspective.
         */
        function simulateEndgame(move) {
            // Create a deep copy of the game state to simulate on
            let tempHLines = JSON.parse(JSON.stringify(hLines));
            let tempVLines = JSON.parse(JSON.stringify(vLines));
            let tempBoxes = JSON.parse(JSON.stringify(boxes));
            
            // Apply the AI's sacrificial move
            if (move.type === 'h') {
                tempHLines[move.x][move.y] = currentPlayer;
            } else {
                tempVLines[move.x][move.y] = currentPlayer;
            }

            // --- Calculate the number of boxes the opponent gets immediately ---
            // This is the length of the chain the AI just opened.
            let boxesGivenAway = 0;
            let newBoxCompleted;
            do {
                newBoxCompleted = false;
                for (let i = 0; i < BOXES; i++) {
                    for (let j = 0; j < BOXES; j++) {
                        // If a box is not yet owned and now has 4 sides
                        if (!tempBoxes[i][j] && countSidesOnTemp(i, j, tempHLines, tempVLines) === 4) {
                            tempBoxes[i][j] = 'opponent'; // Mark as taken by opponent in simulation
                            boxesGivenAway++;
                            newBoxCompleted = true;
                            
                            // To continue the simulation, we need to fill in the last line of this box
                            // so analyzeChains works correctly. Find the missing line and fill it.
                            if (!tempHLines[i][j]) tempHLines[i][j] = 'opponent';
                            else if (!tempHLines[i][j + 1]) tempHLines[i][j + 1] = 'opponent';
                            else if (!tempVLines[i][j]) tempVLines[i][j] = 'opponent';
                            else if (!tempVLines[i + 1][j]) tempVLines[i + 1][j] = 'opponent';
                        }
                    }
                }
            } while (newBoxCompleted);

            // --- Distribute the remaining chains ---
            // Find all remaining chains of 2-sided boxes
            const remainingChains = analyzeChains(tempHLines, tempVLines);
            
            // Sort chains by length, smallest to largest
            remainingChains.sort((a, b) => a - b);

            let myScoreFromChains = 0;
            let opponentScoreFromChains = 0;

            // After the AI's sacrifice, the opponent must open the next chain.
            // They will open the smallest one, which the AI will get.
            for (let i = 0; i < remainingChains.length; i++) {
                if (i % 2 === 0) { // AI gets the 1st, 3rd, 5th... smallest chains
                    myScoreFromChains += remainingChains[i];
                } else { // Opponent gets the 2nd, 4th, 6th...
                    opponentScoreFromChains += remainingChains[i];
                }
            }

            // The net score is the difference between what the AI gets and what the opponent gets.
            const opponentTotalScore = boxesGivenAway + opponentScoreFromChains;
            const myTotalScore = myScoreFromChains;
            
            return myTotalScore - opponentTotalScore;
        }
        
        function analyzeSafeMove(move) {
            let tempHLines = JSON.parse(JSON.stringify(hLines));
            let tempVLines = JSON.parse(JSON.stringify(vLines));
            if (move.type === 'h') tempHLines[move.x][move.y] = currentPlayer;
            else tempVLines[move.x][move.y] = currentPlayer;
            let twoSidedBoxes = 0;
            for (let i = 0; i < BOXES; i++) {
                for (let j = 0; j < BOXES; j++) {
                    if (countSidesOnTemp(i, j, tempHLines, tempVLines) === 2) {
                        twoSidedBoxes++;
                    }
                }
            }
            return twoSidedBoxes;
        }

        function getBestMove() {
            let safeMoves = [], sacrificialMoves = [], winningMoves = [];
            
            // Prioritize winning moves that complete a box
            for (let i = 0; i < BOXES; i++) {
                for (let j = 0; j < DOTS; j++) {
                    if (!hLines[i][j]) {
                        if ((j < BOXES && countSides(i, j) === 3) || (j > 0 && countSides(i, j - 1) === 3)) {
                            winningMoves.push({ type: 'h', x: i, y: j });
                        }
                    }
                }
            }
             for (let i = 0; i < DOTS; i++) {
                for (let j = 0; j < BOXES; j++) {
                    if (!vLines[i][j]) {
                        if ((i < BOXES && countSides(i, j) === 3) || (i > 0 && countSides(i - 1, j) === 3)) {
                            winningMoves.push({ type: 'v', x: i, y: j });
                        }
                    }
                }
            }
            if(winningMoves.length > 0) return winningMoves[0];


            // Categorize all other possible moves
            for (let i = 0; i < BOXES; i++) {
                for (let j = 0; j < DOTS; j++) {
                    if (!hLines[i][j]) {
                        // Temporarily make the move to check its consequences
                        hLines[i][j] = currentPlayer; 
                        let createsThirdSide = false;
                        if (j < BOXES && countSides(i, j) === 3) createsThirdSide = true;
                        if (j > 0 && countSides(i, j - 1) === 3) createsThirdSide = true;
                        hLines[i][j] = 0; // Revert the move
                        
                        if (createsThirdSide) {
                            sacrificialMoves.push({ type: 'h', x: i, y: j });
                        } else {
                            safeMoves.push({ type: 'h', x: i, y: j });
                        }
                    }
                }
            }
            for (let i = 0; i < DOTS; i++) {
                for (let j = 0; j < BOXES; j++) {
                    if (!vLines[i][j]) {
                        // Temporarily make the move to check its consequences
                        vLines[i][j] = currentPlayer;
                        let createsThirdSide = false;
                        if (i < BOXES && countSides(i, j) === 3) createsThirdSide = true;
                        if (i > 0 && countSides(i - 1, j) === 3) createsThirdSide = true;
                        vLines[i][j] = 0; // Revert the move

                        if (createsThirdSide) {
                            sacrificialMoves.push({ type: 'v', x: i, y: j });
                        } else {
                            safeMoves.push({ type: 'v', x: i, y: j });
                        }
                    }
                }
            }
            
            // Strategy 1: If there are safe moves, pick the one that creates the fewest 2-sided boxes
            if (safeMoves.length > 0) {
                let minScore = Infinity;
                let bestSafeMoves = [];
                for (const move of safeMoves) {
                    const score = analyzeSafeMove(move);
                    if (score < minScore) {
                        minScore = score;
                        bestSafeMoves = [move];
                    } else if (score === minScore) {
                        bestSafeMoves.push(move);
                    }
                }
                return bestSafeMoves[Math.floor(Math.random() * bestSafeMoves.length)];
            }
            
            // Strategy 2: If we MUST make a sacrifice, use the simulation to pick the best one
            if (sacrificialMoves.length > 0) {
                let bestScoreDiff = -Infinity;
                let bestMoves = [];
                for (const move of sacrificialMoves) {
                    const scoreDiff = simulateEndgame(move);
                    if (scoreDiff > bestScoreDiff) {
                        bestScoreDiff = scoreDiff;
                        bestMoves = [move];
                    } else if (scoreDiff === bestScoreDiff) {
                        bestMoves.push(move);
                    }
                }
                return bestMoves[Math.floor(Math.random() * bestMoves.length)];
            }

            return null; // No moves left
        }

        // --- Event Listeners ---
        canvas.addEventListener('mousedown', handleInteraction);
        canvas.addEventListener('touchstart', handleInteraction);
        newGameBtn.addEventListener('click', init);
        restartBtn.addEventListener('click', init);
        skipBtn.addEventListener('click', skipTurn);
        undoBtn.addEventListener('click', undoMove);
        window.addEventListener('resize', resizeCanvas);
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', draw);
        assistRedBtn.addEventListener('click', () => selectAiPlayer('red'));
        assistBlueBtn.addEventListener('click', () => selectAiPlayer('blue'));
        startRedBtn.addEventListener('click', () => selectStartingPlayer('red'));
        startBlueBtn.addEventListener('click', () => selectStartingPlayer('blue'));
        startGameBtn.addEventListener('click', startGame);

        // --- Initial Game Setup ---
        init();
    </script>
</body>
</html>
